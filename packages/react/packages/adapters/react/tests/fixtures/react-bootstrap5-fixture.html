<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TouchSpin React Adapter Test - Bootstrap 5</title>
    <link rel="stylesheet" href="/devdist/renderers/bootstrap5/external/css/bootstrap.min.css" />
  </head>
  <body>
    <div id="root"></div>

    <!-- React & React DOM from CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Load TouchSpin Core and Bootstrap5 Renderer -->
    <script src="/devdist/core/iife/index.global.js"></script>
    <script src="/devdist/renderers/bootstrap5/iife/Bootstrap5Renderer.global.js"></script>

    <!-- Test harness script -->
    <script type="module">
      const { React } = window;
      const { createElement: h, useState, useRef, useEffect, forwardRef } = React;
      const { createRoot } = window.ReactDOM;

      // Inline simplified TouchSpin React component for testing
      // (Since we can't easily import ESM modules in this context)

      const useTouchSpin = (options) => {
        const {
          value: controlledValue,
          defaultValue = 0,
          onChange,
          min,
          max,
          step,
          decimals,
          prefix,
          suffix,
          disabled,
          readOnly,
          coreOptions,
          renderer,
        } = options;

        const inputRef = useRef(null);
        const instanceRef = useRef(null);
        const isControlled = controlledValue !== undefined;

        const [internalValue, setInternalValue] = useState(defaultValue);
        const currentValue = isControlled ? controlledValue : internalValue;

        // Mount/unmount TouchSpin
        useEffect(() => {
          if (!inputRef.current) return;

          const input = inputRef.current;
          input.value = String(currentValue);

          instanceRef.current = window.TouchSpinCore.TouchSpin(input, {
            min,
            max,
            step,
            decimals,
            prefix,
            suffix,
            renderer,
            ...coreOptions,
          });

          // Listen to native change event instead of .on('change')
          // (Public API doesn't expose .on method)
          const handleChange = (e) => {
            const numValue = Number(e.target.value);
            if (!isControlled) {
              setInternalValue(numValue);
            }
            onChange?.(numValue, { source: 'user', action: 'input' });
          };

          input.addEventListener('change', handleChange);

          return () => {
            input.removeEventListener('change', handleChange);
            instanceRef.current?.destroy();
            instanceRef.current = null;
          };
        }, [renderer]);

        // Update value when controlled value changes
        useEffect(() => {
          if (isControlled && instanceRef.current) {
            const currentInstanceValue = instanceRef.current.getValue();
            if (currentInstanceValue !== controlledValue) {
              instanceRef.current.setValue(controlledValue);
            }
          }
        }, [isControlled, controlledValue]);

        // Update settings when props change
        useEffect(() => {
          if (!instanceRef.current) return;
          instanceRef.current.updateSettings({
            min, max, step, decimals, prefix, suffix,
          });
        }, [min, max, step, decimals, prefix, suffix]);

        // Update disabled/readonly
        useEffect(() => {
          if (!inputRef.current) return;
          if (disabled !== undefined) {
            inputRef.current.disabled = disabled;
          }
          if (readOnly !== undefined) {
            inputRef.current.readOnly = readOnly;
          }
        }, [disabled, readOnly]);

        return { inputRef, instanceRef, currentValue };
      };

      const TouchSpinComponent = forwardRef((props, ref) => {
        const {
          value,
          defaultValue,
          onChange,
          min,
          max,
          step,
          decimals,
          prefix,
          suffix,
          disabled,
          readOnly,
          name,
          id,
          className,
          inputClassName,
          onBlur,
          onFocus,
          inputProps,
          'data-testid': testId,
          coreOptions,
          renderer,
        } = props;

        const { inputRef, instanceRef, currentValue } = useTouchSpin({
          value,
          defaultValue,
          onChange,
          min,
          max,
          step,
          decimals,
          prefix,
          suffix,
          disabled,
          readOnly,
          coreOptions,
          renderer,
        });

        // Expose imperative handle
        React.useImperativeHandle(ref, () => ({
          focus: () => inputRef.current?.focus(),
          blur: () => inputRef.current?.blur(),
          increment: () => instanceRef.current?.upOnce(),
          decrement: () => instanceRef.current?.downOnce(),
          getValue: () => instanceRef.current?.getValue() ?? currentValue,
          setValue: (val) => instanceRef.current?.setValue(val),
        }), [currentValue]);

        const inputTestId = testId ? `${testId}-input` : undefined;

        return h('div', { className, 'data-testid': testId },
          h('input', {
            ref: inputRef,
            type: 'number',
            name,
            id,
            className: inputClassName,
            disabled,
            readOnly,
            onBlur,
            onFocus,
            'data-testid': inputTestId,
            ...inputProps,
          }),
          name && h('input', {
            type: 'hidden',
            name: `${name}_display`,
            value: currentValue,
          })
        );
      });

      TouchSpinComponent.displayName = 'TouchSpin';

      // Test app component
      const TestApp = () => {
        const [controlledValue, setControlledValue] = useState(50);
        const [uncontrolledKey, setUncontrolledKey] = useState(0);
        const controlledRef = useRef(null);
        const uncontrolledRef = useRef(null);

        // Expose test interface to window for Playwright
        useEffect(() => {
          window.testInterface = {
            setControlledValue,
            getControlledValue: () => controlledValue,
            getControlledRef: () => controlledRef.current,
            getUncontrolledRef: () => uncontrolledRef.current,
            remountUncontrolled: () => setUncontrolledKey(k => k + 1),
          };
        }, [controlledValue]);

        return h('div', { className: 'container mt-4' },
          h('h2', {}, 'Controlled Component'),
          h('div', { 'data-testid': 'controlled-container' },
            h(TouchSpinComponent, {
              ref: controlledRef,
              'data-testid': 'controlled',
              value: controlledValue,
              onChange: (val) => setControlledValue(val),
              min: 0,
              max: 100,
              step: 1,
              renderer: window.Bootstrap5Renderer.default,
            })
          ),
          h('div', { className: 'mt-2' },
            h('span', { 'data-testid': 'controlled-display' }, `Controlled: ${controlledValue}`)
          ),

          h('h2', { className: 'mt-4' }, 'Uncontrolled Component'),
          h('div', { 'data-testid': 'uncontrolled-container' },
            h(TouchSpinComponent, {
              ref: uncontrolledRef,
              key: uncontrolledKey,
              'data-testid': 'uncontrolled',
              defaultValue: 25,
              min: 0,
              max: 100,
              step: 5,
              renderer: window.Bootstrap5Renderer.default,
            })
          ),

          h('h2', { className: 'mt-4' }, 'Form Integration'),
          h('form', {
            'data-testid': 'test-form',
            onSubmit: (e) => {
              e.preventDefault();
              const formData = new FormData(e.target);
              const data = {};
              formData.forEach((value, key) => {
                data[key] = value;
              });
              window.lastFormData = data;
            },
          },
            h(TouchSpinComponent, {
              'data-testid': 'form-input',
              name: 'quantity',
              defaultValue: 10,
              min: 1,
              max: 50,
              step: 1,
              renderer: window.Bootstrap5Renderer.default,
            }),
            h('button', {
              type: 'submit',
              className: 'btn btn-primary mt-2',
              'data-testid': 'submit-btn',
            }, 'Submit')
          ),

          h('h2', { className: 'mt-4' }, 'Disabled State'),
          h('div', { 'data-testid': 'disabled-container' },
            h(TouchSpinComponent, {
              'data-testid': 'disabled',
              defaultValue: 30,
              min: 0,
              max: 100,
              step: 1,
              disabled: true,
              renderer: window.Bootstrap5Renderer.default,
            })
          ),

          h('h2', { className: 'mt-4' }, 'ARIA Attributes'),
          h('div', { 'data-testid': 'aria-container' },
            h(TouchSpinComponent, {
              'data-testid': 'aria',
              defaultValue: 42,
              min: 10,
              max: 90,
              step: 2,
              renderer: window.Bootstrap5Renderer.default,
            })
          )
        );
      };

      // Mount app when DOM is ready
      const root = createRoot(document.getElementById('root'));
      root.render(h(TestApp));
    </script>
  </body>
</html>
